(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{402:function(t,a,e){"use strict";e.r(a);var n=e(10),r=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"单例模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[t._v("#")]),t._v(" 单例模式")]),t._v(" "),a("p",[t._v("Spring 创建 Bean 实例时，如果是 Singleton 作用域，那么就是以单例模式创建的。")]),t._v(" "),a("h1",{attrs:{id:"原型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型模式"}},[t._v("#")]),t._v(" 原型模式")]),t._v(" "),a("p",[t._v("Spring 创建 Bean 实例时，如果是 Prototype 作用域，那么就是以原型模式创建的。")]),t._v(" "),a("h1",{attrs:{id:"简单工厂模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂模式"}},[t._v("#")]),t._v(" 简单工厂模式")]),t._v(" "),a("p",[t._v("BeanFactory 就是简单工厂模式的体现，根据传入一个唯一标识来获得 Bean 对象。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBean")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throws")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BeansException")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("assertBeanFactoryActive")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBeanFactory")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBean")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h1",{attrs:{id:"工厂方法模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法模式"}},[t._v("#")]),t._v(" 工厂方法模式")]),t._v(" "),a("p",[t._v("FactoryBean 就是典型的工厂方法模式。Spring 在使用"),a("code",[t._v("getBean()")]),t._v("调用获得该 Bean 时，会自动调用该 Bean 的"),a("code",[t._v("getObject()")]),t._v("方法。每个 Bean 都会对应一个 FactoryBean，如 SqlSessionFactory 对应 SqlSessionFactoryBean。")]),t._v(" "),a("h1",{attrs:{id:"适配器模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[t._v("#")]),t._v(" 适配器模式")]),t._v(" "),a("p",[t._v("SpringMVC 中的适配器 HandlerAdatper。")]),t._v(" "),a("p",[t._v("由于应用会有多个 Controller 实现，如果需要直接调用 Controller 方法，那么需要先判断是由哪一个 Controller 处理请求，然后调用相应的方法。当增加新的 Controller，需要修改原来的逻辑，违反了开闭原则（对修改关闭，对扩展开放）。")]),t._v(" "),a("p",[t._v("为此，Spring 提供了一个适配器接口，每一种 Controller 对应一种 HandlerAdapter 实现类，当请求过来，SpringMVC 会调用 "),a("code",[t._v("getHandler()")]),t._v(" 获取相应的 Controller，然后获取该 Controller 对应的 HandlerAdapter，最后调用"),a("code",[t._v("HandlerAdapter的handle()")]),t._v("方法处理请求，实际上调用的是 Controller 的 "),a("code",[t._v("handleRequest()")]),t._v("。每次添加新的 Controller 时，只需要增加一个适配器类就可以，无需修改原有的逻辑。")]),t._v(" "),a("p",[t._v("常用的处理器适配器：SimpleControllerHandlerAdapter，HttpRequestHandlerAdapter，AnnotationMethodHandlerAdapter。")]),t._v(" "),a("h1",{attrs:{id:"代理模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[t._v("#")]),t._v(" 代理模式")]),t._v(" "),a("p",[t._v("spring 的 aop 使用了动态代理，有两种方式 JdkDynamicAopProxy 和 Cglib2AopProxy。")]),t._v(" "),a("h1",{attrs:{id:"观察者模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[t._v("#")]),t._v(" 观察者模式")]),t._v(" "),a("p",[t._v("spring 中 observer 模式常用的地方是 listener 的实现，如 ApplicationListener。")]),t._v(" "),a("h1",{attrs:{id:"模板模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板模式"}},[t._v("#")]),t._v(" 模板模式")]),t._v(" "),a("p",[t._v("Spring 中 jdbcTemplate、hibernateTemplate 等，就使用到了模板模式。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("摘自：")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://topjavaer.cn/framework/spring.html#spring-%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring 用到了哪些设计模式？"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("站长略有修改")])])}),[],!1,null,null,null);a.default=r.exports}}]);