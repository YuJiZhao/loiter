(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{371:function(t,a,e){"use strict";e.r(a);var s=e(10),n=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("AQS 的全称为 AbstractQueuedSynchronizer，翻译过来的意思就是抽象队列同步器。这个抽象类在 "),a("code",[t._v("java.util.concurrent.locks")]),t._v(" 包下面。AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue 等等皆是基于 AQS 的。")]),t._v(" "),a("h1",{attrs:{id:"aqs原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aqs原理"}},[t._v("#")]),t._v(" AQS原理")]),t._v(" "),a("p",[t._v("AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的。")]),t._v(" "),a("p",[t._v("CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。")]),t._v(" "),a("p",[t._v("在 CLH 队列锁中，一个 Node 表示一个线程，它保存着如下数据：")]),t._v(" "),a("ul",[a("li",[t._v("thread：引用线程，头节点不包含线程")]),t._v(" "),a("li",[t._v("waitStatus：当前节点在队列中的状态\n"),a("ul",[a("li",[a("code",[t._v("0")]),t._v("：节点初始化时的状态")]),t._v(" "),a("li",[a("code",[t._v("CANCELLED = 1")]),t._v("：节点引用线程由于等待超时或被打断时的状态")]),t._v(" "),a("li",[a("code",[t._v("SIGNAL = -1")]),t._v("：后继节点线程需要被唤醒时的当前节点状态。当队列中加入后继节点被挂起（block）时，其前驱节点会被设置为 SIGNAL 状态，表示该节点需要被唤醒")]),t._v(" "),a("li",[a("code",[t._v("CONDITION = -2")]),t._v("：当节点线程进入 condition 队列时的状态")]),t._v(" "),a("li",[a("code",[t._v("PROPAGATE = -3")]),t._v("：仅在释放共享锁 releaseShared 时对头节点使用")])])]),t._v(" "),a("li",[t._v("prev：前驱节点")]),t._v(" "),a("li",[t._v("next：后继节点")])]),t._v(" "),a("p",[a("img",{attrs:{src:"http://hunt-cdn.eyescode.top/content/50661d8f-e68e-8586-e9c4-1b471ea779c4.png",alt:"CLH"}})]),t._v(" "),a("p",[t._v("AQS（AbstractQueuedSynchronizer）的核心原理图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://hunt-cdn.eyescode.top/content/718b71fa-cdc5-cb26-fe0a-634f0e0bbc3e.png",alt:"AQS 核心原理"}})]),t._v(" "),a("p",[t._v("AQS 使用 int 成员变量 state 表示同步状态，通过内置的 FIFO 线程等待/等待队列 来完成获取资源线程的排队工作。state 变量由 volatile 修饰，用于展示当前临界资源的获锁情况：")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 共享变量，使用 volatile 修饰保证线程可见性")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对于不同的实现类，state 的值有不同的意义，所以这里不多说明")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("另外，状态信息 state 可以通过 protected 类型的"),a("code",[t._v("getState()")]),t._v("、"),a("code",[t._v("setState()")]),t._v("和"),a("code",[t._v("compareAndSetState()")]),t._v("进行操作。并且，这几个方法都是 final 修饰的，在子类中无法被重写。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回同步状态的当前值")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置同步状态的值")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" newState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    state "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" newState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 原子地（CAS操作）将同步状态值设置为给定值。如果当前同步状态的值等于expect（期望值）则更新")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" expect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" update"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" unsafe"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSwapInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" stateOffset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" expect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" update"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h1",{attrs:{id:"aqs-资源共享方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aqs-资源共享方式"}},[t._v("#")]),t._v(" AQS 资源共享方式")]),t._v(" "),a("p",[t._v("AQS 定义两种资源共享方式：")]),t._v(" "),a("ul",[a("li",[t._v("Exclusive（独占）：只有一个线程能执行，如 ReentrantLock")]),t._v(" "),a("li",[t._v("Share（共享）：多个线程可同时执行，如 Semaphore、CountDownLatch")])]),t._v(" "),a("p",[t._v("一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现"),a("code",[t._v("tryAcquire-tryRelease")]),t._v("、"),a("code",[t._v("tryAcquireShared-tryReleaseShared")]),t._v("中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。")]),t._v(" "),a("h1",{attrs:{id:"自定义同步器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义同步器"}},[t._v("#")]),t._v(" 自定义同步器")]),t._v(" "),a("p",[t._v("同步器的设计是基于模板方法模式的，如果需要自定义同步器，一般的方式是这样（模板方法模式很经典的一个应用）：")]),t._v(" "),a("ol",[a("li",[t._v("使用者继承 "),a("code",[t._v("AbstractQueuedSynchronizer")]),t._v(" 并重写指定的方法")]),t._v(" "),a("li",[t._v("将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。")])]),t._v(" "),a("p",[t._v("这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 独占方式。尝试获取资源，成功则返回 true，失败则返回 false")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 独占方式。尝试释放资源，成功则返回 true，失败则返回 false")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryRelease")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquireShared")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 共享方式。尝试释放资源，成功则返回 true，失败则返回 false")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryReleaseShared")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 该线程是否正在独占资源。只有用到 condition 才需要去实现它")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isHeldExclusively")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("什么是钩子方法呢？ 钩子方法是一种被声明在抽象类中的方法，一般使用 protected 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。除了上面提到的钩子方法之外，AQS 类中的其他方法都是 final ，所以无法被其他类重写。")]),t._v(" "),a("h1",{attrs:{id:"为什么aqs是双向链表而不是单向的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么aqs是双向链表而不是单向的"}},[t._v("#")]),t._v(" 为什么AQS是双向链表而不是单向的？")]),t._v(" "),a("p",[t._v("双向链表有两个指针，一个指针指向前置节点，一个指针指向后继节点。所以，双向链表可以支持常量 "),a("code",[t._v("O(1)")]),t._v(" 时间复杂度的情况下找到前驱节点。因此，双向链表在插入和删除操作的时候，要比单向链表简单、高效。")]),t._v(" "),a("p",[t._v("从双向链表的特性来看，AQS 使用双向链表有两个方面的原因：")]),t._v(" "),a("ul",[a("li",[t._v("没有竞争到锁的线程加入到阻塞队列，并且阻塞等待的前提是，当前线程所在节点的前置节点是正常状态，这样设计是为了避免链表中存在异常线程导致无法唤醒后续线程的问题。所以，线程阻塞之前需要判断前置节点的状态，如果没有指针指向前置节点，就需要从 Head 节点开始遍历，性能非常低。")]),t._v(" "),a("li",[t._v("在 Lock 接口里面有一个"),a("code",[t._v("lockInterruptibly()")]),t._v("方法，这个方法表示处于锁阻塞的线程允许被中断。也就是说，没有竞争到锁的线程加入到同步队列等待以后，是允许外部线程通过"),a("code",[t._v("interrupt()")]),t._v("方法触发唤醒并中断的。这个时候，被中断的线程的状态会修改成 CANCELLED。而被标记为 CANCELLED 状态的线程，是不需要去竞争锁的，但是它仍然存在于双向链表里面。这就意味着在后续的锁竞争中，需要把这个节点从链表里面移除，否则会导致锁阻塞的线程无法被正常唤醒。在这种情况下，如果是单向链表，就需要从 Head 节点开始往下逐个遍历，找到并移除异常状态的节点。同样效率也比较低，还会导致锁唤醒的操作和遍历操作之间的竞争。")])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("摘自：")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://javaguide.cn/java/concurrent/aqs.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("AQS 详解"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.cn/post/7006895386103119908",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java并发之AQS详解"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://topjavaer.cn/java/java-concurrent.html#%E4%B8%BA%E4%BB%80%E4%B9%88aqs%E6%98%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8D%95%E5%90%91%E7%9A%84",target:"_blank",rel:"noopener noreferrer"}},[t._v("为什么AQS是双向链表而不是单向的？"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("站长略有修改")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("待补充：")]),t._v(" "),a("ul",[a("li",[t._v("AQS工作流程")]),t._v(" "),a("li",[t._v("AQS唤醒节点时，为什么是从后往前找")])])])}),[],!1,null,null,null);a.default=n.exports}}]);