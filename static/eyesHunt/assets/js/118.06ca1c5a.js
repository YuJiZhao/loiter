(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{397:function(e,n,t){"use strict";t.r(n);var o=t(10),a=Object(o.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Spring Bean 的生命周期可以分为以下几个阶段：")]),e._v(" "),n("ol",[n("li",[e._v("实例化（Instantiation）：当 Spring 容器启动时，会根据配置文件或注解等方式创建 Bean 实例")]),e._v(" "),n("li",[e._v("属性赋值（Populate）：在实例化后，Spring 容器会将配置文件或注解中的属性值注入到 Bean 实例中")]),e._v(" "),n("li",[e._v("BeanPostProcessor 的前置处理：在 Bean 实例化和属性赋值之后，Spring 容器会调用所有实现了 BeanPostProcessor 接口的类的 postProcessBeforeInitialization 方法，对 Bean 进行前置处理")]),e._v(" "),n("li",[e._v("初始化（Initialization）：在属性赋值完成后，Spring 容器会调用 Bean 的初始化方法，可以通过实现 InitializingBean 接口或在配置文件中指定 init-method 来定义初始化方法")]),e._v(" "),n("li",[e._v("BeanPostProcessor 的后置处理：在 Bean 初始化方法执行完成后，Spring 容器会调用所有实现了 BeanPostProcessor 接口的类的 postProcessAfterInitialization 方法，对 Bean 进行后置处理")]),e._v(" "),n("li",[e._v("销毁（Destruction）：当 Spring 容器关闭时，会调用 Bean 的销毁方法，可以通过实现 DisposableBean 接口或在配置文件中指定 destroy-method 来定义销毁方法")])]),e._v(" "),n("p",[e._v("需要注意的是，Spring Bean 的生命周期并不是线性的，可能会在某个阶段中断或回到之前的阶段。例如，在初始化阶段中，如果发生异常，则会回到实例化阶段重新创建 Bean 实例。")]),e._v(" "),n("p",[e._v("在这个过程中，可以通过实现接口或在配置文件中指定方法来定义 Bean 的初始化和销毁方法：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("@PostConstruct")]),e._v("：用于在 Bean 初始化之后执行一些操作。这个注解可以用在方法上，方法会在 Bean 初始化之后被调用")]),e._v(" "),n("li",[n("code",[e._v("@PreDestroy")]),e._v("：用于在 Bean 销毁之前执行一些操作。这个注解可以用在方法上，方法会在 Bean 销毁之前被调用")])]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("摘自：")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"http://space.eyescode.top/blog/details/245",target:"_blank",rel:"noopener noreferrer"}},[e._v("java八股系列——Spring Bean的作用域与生命周期"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=a.exports}}]);